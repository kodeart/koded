{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Koded Web Framework \u00b6 Why? \u00b6 Sometimes we want a prototype, or quick/simple operations, or solutions for building fast web APIs and app backends. And having a full-blown frameworks will eventually weight you down with tons of unnecessary abstractions and dependencies. Koded offers small footprint with a clean design that follows the HTTP and ReST architectural style. It tends to be very fast and easy to work with. Minimum application \u00b6 <?php use Koded\\Framework\\App ; use Koded\\Http\\ServerResponse as R ; require __DIR__ . '/../vendor/autoload.php' ; (( new App ) -> route ( '/' , fn () => new R ( 'Hello' )) )(); This fits in a tweet. Resource Method Representation \u00b6 Koded Framework follows the RMR web architectural pattern , but the developer is free to use whatever it prefers and does not enforce any programming patterns in the application. However, it is strongly recommended adopting and using RMR because it is aligned nicely with the HTTP ReST concepts. After all, web apps needs fundamental directions and principles, not \"perfect\" solutions so RMR fits here very well. Resource An object in the RESTful system identified by a URL that exposes methods that corresponds to the standard HTTP methods (GET, POST, PUT, etc) i.e. a business object (entity). Method The HTTP request method that corresponds a Resource method that is executed by the request/URL, which returns a Representation for that resource. Representation Provides a Resource to clients in a readable format (JSON, XML, PDF, HTML, etc). It is the payload of the response object (processed by the HTTP Method that is sent back to the client).","title":"Intro"},{"location":"#the-koded-web-framework","text":"","title":"The Koded Web Framework"},{"location":"#why","text":"Sometimes we want a prototype, or quick/simple operations, or solutions for building fast web APIs and app backends. And having a full-blown frameworks will eventually weight you down with tons of unnecessary abstractions and dependencies. Koded offers small footprint with a clean design that follows the HTTP and ReST architectural style. It tends to be very fast and easy to work with.","title":"Why?"},{"location":"#minimum-application","text":"<?php use Koded\\Framework\\App ; use Koded\\Http\\ServerResponse as R ; require __DIR__ . '/../vendor/autoload.php' ; (( new App ) -> route ( '/' , fn () => new R ( 'Hello' )) )(); This fits in a tweet.","title":"Minimum application"},{"location":"#resource-method-representation","text":"Koded Framework follows the RMR web architectural pattern , but the developer is free to use whatever it prefers and does not enforce any programming patterns in the application. However, it is strongly recommended adopting and using RMR because it is aligned nicely with the HTTP ReST concepts. After all, web apps needs fundamental directions and principles, not \"perfect\" solutions so RMR fits here very well. Resource An object in the RESTful system identified by a URL that exposes methods that corresponds to the standard HTTP methods (GET, POST, PUT, etc) i.e. a business object (entity). Method The HTTP request method that corresponds a Resource method that is executed by the request/URL, which returns a Representation for that resource. Representation Provides a Resource to clients in a readable format (JSON, XML, PDF, HTML, etc). It is the payload of the response object (processed by the HTTP Method that is sent back to the client).","title":"Resource Method Representation"},{"location":"default-dependencies/","text":"Default framework dependencies \u00b6 Framework DI module \u00b6 It loads the following dependencies by default: Interfaces \u00b6 See implementations and shared instances . HTTP \u00b6 PSR-7 Psr\\Http\\Message\\ServerRequestInterface PSR-7 Psr\\Http\\Message\\ResponseInterface Koded\\Framework\\Request Koded\\Framework\\Response Authentication \u00b6 Framework\\Auth\\AuthBackend Used in the AuthMiddleware - Framework\\Auth\\AuthProcessor Executes the authenticate() in the AuthMiddleware Application should override the AuthBackend to provide its own authentication storage and logic (i.e. database). The AuthProcessor parses the credentials and may be overridden to support different types of auth mechanisms (i.e. JWT) Utility \u00b6 PSR-16 Psr\\SimpleCache\\CacheInterface PSR-3 Psr\\Log\\LoggerInterface Koded\\Stdlib\\Configuration Middleware \u00b6 Koded uses PSR-15 middlewares. More details on the middleware page Bindings \u00b6 Anything that's bound by the default DI module can be replaced with custom implementation(s) in your application DI module(s). The default classes are from the Koded libraries .","title":"Default framework dependencies"},{"location":"default-dependencies/#default-framework-dependencies","text":"","title":"Default framework dependencies"},{"location":"default-dependencies/#framework-di-module","text":"It loads the following dependencies by default:","title":"Framework DI module"},{"location":"default-dependencies/#interfaces","text":"See implementations and shared instances .","title":"Interfaces"},{"location":"default-dependencies/#http","text":"PSR-7 Psr\\Http\\Message\\ServerRequestInterface PSR-7 Psr\\Http\\Message\\ResponseInterface Koded\\Framework\\Request Koded\\Framework\\Response","title":"HTTP"},{"location":"default-dependencies/#authentication","text":"Framework\\Auth\\AuthBackend Used in the AuthMiddleware - Framework\\Auth\\AuthProcessor Executes the authenticate() in the AuthMiddleware Application should override the AuthBackend to provide its own authentication storage and logic (i.e. database). The AuthProcessor parses the credentials and may be overridden to support different types of auth mechanisms (i.e. JWT)","title":"Authentication"},{"location":"default-dependencies/#utility","text":"PSR-16 Psr\\SimpleCache\\CacheInterface PSR-3 Psr\\Log\\LoggerInterface Koded\\Stdlib\\Configuration","title":"Utility"},{"location":"default-dependencies/#middleware","text":"Koded uses PSR-15 middlewares. More details on the middleware page","title":"Middleware"},{"location":"default-dependencies/#bindings","text":"Anything that's bound by the default DI module can be replaced with custom implementation(s) in your application DI module(s). The default classes are from the Koded libraries .","title":"Bindings"},{"location":"exception-handlers/","text":"Exception handling \u00b6 By default, the following exceptions are caught and handled \\Exception \\Error Koded\\Framework\\HTTPError The error response payload follows the RFC-7807 specification. If you wish to capture specific exception types and/or return custom error messages, create your own class and register it with the method App::withErrorHandler() to convert the exceptions into the desired HTTP responses. handle() method signature handle(request, response, exception): void If app does not use 3rd party PSR-7 library, then Koded will use its own implementations from the Koded HTTP library. <?php # CustomExceptionHandler.php use Koded\\Framework\\ { App , HTTPError }; use Koded\\Http\\Interfaces\\ { Request , Response }; class CustomExceptionHandler { public static function handle ( Request $request , Response $response , HTTPError $exception ) : void { // do something with $exception // i.e. re-format the error message and set it in the response } } Register handler \u00b6 Register before routes Order matters. It is required to register the custom exception handlers BEFORE the routes, otherwise they won't be handled if the request/route has been resolved. <?php # index.php (( new App ) -> withErrorHandler ( CustomExceptionHandler :: class ) -> route ( /* ... */ ) )(); This implementation is using a PSR-7 compatible library and a standard PHP Throwable class. <?php use Psr\\Http\\Message\\ { ServerRequestInterface , ResponseInterface }; class PDOExceptionHandler { public static function handle ( ServerRequestInterface $request , ResponseInterface $response , \\Throwable $exception ) : void { if ( $exception instanceof \\PDOException ) { // do something about it } } } Unregister handler \u00b6 Use App::withoutErrorHandler() method to remove the error handler. Unregister after custom handlers Order matters. Unregister the exception handlers AFTER the custom registration, otherwise they won't be removed. <?php # index.php (( new App ) -> withErrorHandler ( SomeCustomErrorHandler :: class ) -> withoutErrorHandler ( AnotherCustomExceptionHandler :: class ) -> route ( /* ... */ ) )();","title":"Exception handling"},{"location":"exception-handlers/#exception-handling","text":"By default, the following exceptions are caught and handled \\Exception \\Error Koded\\Framework\\HTTPError The error response payload follows the RFC-7807 specification. If you wish to capture specific exception types and/or return custom error messages, create your own class and register it with the method App::withErrorHandler() to convert the exceptions into the desired HTTP responses. handle() method signature handle(request, response, exception): void If app does not use 3rd party PSR-7 library, then Koded will use its own implementations from the Koded HTTP library. <?php # CustomExceptionHandler.php use Koded\\Framework\\ { App , HTTPError }; use Koded\\Http\\Interfaces\\ { Request , Response }; class CustomExceptionHandler { public static function handle ( Request $request , Response $response , HTTPError $exception ) : void { // do something with $exception // i.e. re-format the error message and set it in the response } }","title":"Exception handling"},{"location":"exception-handlers/#register-handler","text":"Register before routes Order matters. It is required to register the custom exception handlers BEFORE the routes, otherwise they won't be handled if the request/route has been resolved. <?php # index.php (( new App ) -> withErrorHandler ( CustomExceptionHandler :: class ) -> route ( /* ... */ ) )(); This implementation is using a PSR-7 compatible library and a standard PHP Throwable class. <?php use Psr\\Http\\Message\\ { ServerRequestInterface , ResponseInterface }; class PDOExceptionHandler { public static function handle ( ServerRequestInterface $request , ResponseInterface $response , \\Throwable $exception ) : void { if ( $exception instanceof \\PDOException ) { // do something about it } } }","title":"Register handler"},{"location":"exception-handlers/#unregister-handler","text":"Use App::withoutErrorHandler() method to remove the error handler. Unregister after custom handlers Order matters. Unregister the exception handlers AFTER the custom registration, otherwise they won't be removed. <?php # index.php (( new App ) -> withErrorHandler ( SomeCustomErrorHandler :: class ) -> withoutErrorHandler ( AnotherCustomExceptionHandler :: class ) -> route ( /* ... */ ) )();","title":"Unregister handler"},{"location":"get-started/","text":"Requirements \u00b6 Installation \u00b6 Using composer \u00b6 composer require koded/framework No composer? If you don't have composer please follow the download instructions how to install it on your OS. For manual install on Linux you may run this command: curl https://getcomposer.org/download/latest-stable/composer.phar -o /usr/local/bin/composer \\ && chmod +x /usr/local/bin/composer App basics \u00b6 Files structure \u00b6 It is up to you how you're going to structure your project. A simple and clear structuring is essential for great development, on a long run (or short too), but that is up to developer needs, or based on the app complexity, team decisions, or various other reasons. Let's look at something that is good in general as a startup, app/ .env html/ .htaccess index.php vendor/ composer.json Everything regarding your application goes into the app/ folder. This is an example, app is not a requirement and it can be anything you want. Protect your code! It is important to keep everything outside the html/ folder ( app/ , vendor/ or anything that is app related and may expose the code). Make sure the app code is not accessible from the outside. composer.json \u00b6 A composer.json scaffold for your project. Run composer update every time a new class is added, or use psr-4 in autoload section while you develop the app, whatever you prefer most. { \"require\" : { \"koded/framework\" : \"^1\" }, \"autoload\" : { \"classmap\" : [ \"app\" ], \"exclude-from-classmap\" : [ \"html\" ] }, \"config\" : { \"optimize-autoloader\" : true } } Docker (quick example) \u00b6 You can jumpstart the development with docker and docker-compose with the above app file structure. # docker-compose.yaml version : '3' services : php : image : php:8-apache ports : - 8080:80 volumes : - .:/var/www Adjust the volumes, or the host port if it's already taken. Run docker-compose up -d and open your browser at 127.0.0.1:8080 App entry point \u00b6 Create the \"entry script\" for all HTTP requests. There we create an instance of App and define the URI routes. # /var/www/html/index.php <?php use Koded\\Framework\\App ; use Koded\\Http\\Interfaces\\Response ; require __DIR__ . '/../vendor/autoload.php' ; (( new App ) -> route ( '/' , function ( Response $response ) : Response { $response -> getBody () -> write ( 'Work In Progress...' ); return $response ; }) )(); Now point your browser to app address. It should print \"Work in Progress...\" with status code 200. From here on add more routes and resources to your API, but keep in mind that using closures as resources is NOT the recommended way to build the application. For more on this please follow the documentation further.","title":"Get Started"},{"location":"get-started/#requirements","text":"","title":"Requirements"},{"location":"get-started/#installation","text":"","title":"Installation"},{"location":"get-started/#using-composer","text":"composer require koded/framework No composer? If you don't have composer please follow the download instructions how to install it on your OS. For manual install on Linux you may run this command: curl https://getcomposer.org/download/latest-stable/composer.phar -o /usr/local/bin/composer \\ && chmod +x /usr/local/bin/composer","title":"Using composer"},{"location":"get-started/#app-basics","text":"","title":"App basics"},{"location":"get-started/#files-structure","text":"It is up to you how you're going to structure your project. A simple and clear structuring is essential for great development, on a long run (or short too), but that is up to developer needs, or based on the app complexity, team decisions, or various other reasons. Let's look at something that is good in general as a startup, app/ .env html/ .htaccess index.php vendor/ composer.json Everything regarding your application goes into the app/ folder. This is an example, app is not a requirement and it can be anything you want. Protect your code! It is important to keep everything outside the html/ folder ( app/ , vendor/ or anything that is app related and may expose the code). Make sure the app code is not accessible from the outside.","title":"Files structure"},{"location":"get-started/#composerjson","text":"A composer.json scaffold for your project. Run composer update every time a new class is added, or use psr-4 in autoload section while you develop the app, whatever you prefer most. { \"require\" : { \"koded/framework\" : \"^1\" }, \"autoload\" : { \"classmap\" : [ \"app\" ], \"exclude-from-classmap\" : [ \"html\" ] }, \"config\" : { \"optimize-autoloader\" : true } }","title":"composer.json"},{"location":"get-started/#docker-quick-example","text":"You can jumpstart the development with docker and docker-compose with the above app file structure. # docker-compose.yaml version : '3' services : php : image : php:8-apache ports : - 8080:80 volumes : - .:/var/www Adjust the volumes, or the host port if it's already taken. Run docker-compose up -d and open your browser at 127.0.0.1:8080","title":"Docker (quick example)"},{"location":"get-started/#app-entry-point","text":"Create the \"entry script\" for all HTTP requests. There we create an instance of App and define the URI routes. # /var/www/html/index.php <?php use Koded\\Framework\\App ; use Koded\\Http\\Interfaces\\Response ; require __DIR__ . '/../vendor/autoload.php' ; (( new App ) -> route ( '/' , function ( Response $response ) : Response { $response -> getBody () -> write ( 'Work In Progress...' ); return $response ; }) )(); Now point your browser to app address. It should print \"Work in Progress...\" with status code 200. From here on add more routes and resources to your API, but keep in mind that using closures as resources is NOT the recommended way to build the application. For more on this please follow the documentation further.","title":"App entry point"},{"location":"shared-instances/","text":"Shared instances \u00b6 spec interface default implementation PSR-3 Psr\\Log\\LoggerInterface Koded\\Logging\\Log PSR-16 Psr\\SimpleCache\\CacheInterface Koded\\Caching\\Client\\MemoryClient Koded\\Stdlib\\Configuration Koded\\Stdlib\\Config N/A Koded\\Framework\\Router Default bindings \u00b6 spec interface default implementation PSR-7 Psr\\Http\\Message\\ServerRequestInterface Koded\\Http\\ServerRequest PSR-7 Psr\\Http\\Message\\ResponseInterface Koded\\Http\\ServerResponse PSR-7 Koded\\Http\\Interfaces\\Request Koded\\Http\\ServerRequest PSR-7 Koded\\Http\\Interfaces\\Response Koded\\Http\\ServerResponse Koded\\Framework\\Auth\\AuthBackend Koded\\Framework\\Auth\\SessionAuthBackend Koded\\Framework\\Auth\\AuthProcessor Koded\\Framework\\Auth\\TokenAuthProcessor","title":"Shared instances"},{"location":"shared-instances/#shared-instances","text":"spec interface default implementation PSR-3 Psr\\Log\\LoggerInterface Koded\\Logging\\Log PSR-16 Psr\\SimpleCache\\CacheInterface Koded\\Caching\\Client\\MemoryClient Koded\\Stdlib\\Configuration Koded\\Stdlib\\Config N/A Koded\\Framework\\Router","title":"Shared instances"},{"location":"shared-instances/#default-bindings","text":"spec interface default implementation PSR-7 Psr\\Http\\Message\\ServerRequestInterface Koded\\Http\\ServerRequest PSR-7 Psr\\Http\\Message\\ResponseInterface Koded\\Http\\ServerResponse PSR-7 Koded\\Http\\Interfaces\\Request Koded\\Http\\ServerRequest PSR-7 Koded\\Http\\Interfaces\\Response Koded\\Http\\ServerResponse Koded\\Framework\\Auth\\AuthBackend Koded\\Framework\\Auth\\SessionAuthBackend Koded\\Framework\\Auth\\AuthProcessor Koded\\Framework\\Auth\\TokenAuthProcessor","title":"Default bindings"},{"location":"configure/","text":"App class configuration \u00b6 The configuration object is created by setting the config directives in the Koded\\Framework\\App constructor. Argument Type Required Default modules array no [] A list of DIModules for the app middleware array no [] The app middleware stack config object, string no '' A path to a config file, FQCN of the configuration class, or an instance of a config object renderer string no 'start_response' Response renderer function/method All directives are optional. <?php new App ( modules : [ // a list of DIModule implementation(s) ], middleware : [ // a list of PSR-15 middleware classes (global) ], config : __DIR__ . '/path/to/my/config.php' , // or config : '.env' , // or config : new MyConfig (), renderer : MyRenderer :: class , // or renderer : 'my_renderer_function' ); Constructor arguments \u00b6 modules \u00b6 optional This argument accepts a list of DIModule instances that configures the Dependency Injection Container for your app. See more about DI modules . Example: [ new My\\App\\Module(), ] middleware \u00b6 optional A list of PSR-15 middleware classes for your application. Example: [ // ... your middleware classes My\\App\\Middleware\\CustomMiddleware::class, new My\\App\\Middleware\\Other(), ] Check the PSR-15 middleware stack page for details how Koded framework implements this functionality. config \u00b6 optional Configuration values for your application. It supports .php file that returns an array, or .env file, or instance of Koded\\Stdlib\\Configuration object. Examples: <?php # conf.php return [ 'key' => 'value' , ]; # /var/www/public/index.php new App ( config : '/path/to/conf.php' ); # .env is always loaded (if exist) key = value <?php use Koded\\Framework\\App ; use Koded\\Stdlib\\ { Config , Immutable } $config = new Config ( '/path/to/app/dir' , new Immutable ([ 'key' => 'value' , ])); new App ( config : $config ); .env support Make sure .env file is not accessible from the outside. renderer \u00b6 optional A custom renderer for the processed ResponseInterface object. This method/function is executed by the DI container, meaning the depencencies can be anything that the container is able to resolve. default 'start_response' <?php new App ( renderer : MyCustomRenderer :: class ); new App ( renderer : 'My\\App\\custom_renderer' ); The purpose of this class method (or function) is to provide a custom processing of the ServerRequestInterface and ResponseInterface objects BEFORE it is finally sent to the client, for example a custom-made HTML renderer for server-side template engines, or a response streaming, etc.","title":"App instance"},{"location":"configure/#app-class-configuration","text":"The configuration object is created by setting the config directives in the Koded\\Framework\\App constructor. Argument Type Required Default modules array no [] A list of DIModules for the app middleware array no [] The app middleware stack config object, string no '' A path to a config file, FQCN of the configuration class, or an instance of a config object renderer string no 'start_response' Response renderer function/method All directives are optional. <?php new App ( modules : [ // a list of DIModule implementation(s) ], middleware : [ // a list of PSR-15 middleware classes (global) ], config : __DIR__ . '/path/to/my/config.php' , // or config : '.env' , // or config : new MyConfig (), renderer : MyRenderer :: class , // or renderer : 'my_renderer_function' );","title":"App class configuration"},{"location":"configure/#constructor-arguments","text":"","title":"Constructor arguments"},{"location":"configure/#modules","text":"optional This argument accepts a list of DIModule instances that configures the Dependency Injection Container for your app. See more about DI modules . Example: [ new My\\App\\Module(), ]","title":"modules"},{"location":"configure/#middleware","text":"optional A list of PSR-15 middleware classes for your application. Example: [ // ... your middleware classes My\\App\\Middleware\\CustomMiddleware::class, new My\\App\\Middleware\\Other(), ] Check the PSR-15 middleware stack page for details how Koded framework implements this functionality.","title":"middleware"},{"location":"configure/#config","text":"optional Configuration values for your application. It supports .php file that returns an array, or .env file, or instance of Koded\\Stdlib\\Configuration object. Examples: <?php # conf.php return [ 'key' => 'value' , ]; # /var/www/public/index.php new App ( config : '/path/to/conf.php' ); # .env is always loaded (if exist) key = value <?php use Koded\\Framework\\App ; use Koded\\Stdlib\\ { Config , Immutable } $config = new Config ( '/path/to/app/dir' , new Immutable ([ 'key' => 'value' , ])); new App ( config : $config ); .env support Make sure .env file is not accessible from the outside.","title":"config"},{"location":"configure/#renderer","text":"optional A custom renderer for the processed ResponseInterface object. This method/function is executed by the DI container, meaning the depencencies can be anything that the container is able to resolve. default 'start_response' <?php new App ( renderer : MyCustomRenderer :: class ); new App ( renderer : 'My\\App\\custom_renderer' ); The purpose of this class method (or function) is to provide a custom processing of the ServerRequestInterface and ResponseInterface objects BEFORE it is finally sent to the client, for example a custom-made HTML renderer for server-side template engines, or a response streaming, etc.","title":"renderer"},{"location":"configure/modules/","text":"DIModule interface \u00b6 The purpose of this feature is to setup the DI container in your app. Once your app stops being \"Hello World\" and assuming you are going to follow some SOLID principles (or maybe not), the application may end up with lots of interfaces and concrete implementations. All of them can be mapped in the app module. Koded Container supports multiple modules, but one is sufficient for the container's configuration. Again, it is up to you how you are going to structure the application, so sometimes it makes sense to create multiple modules. Lets say you want to provide a database for the auth backend instance. Because Koded already has one registered by default ( Koded\\Framework\\Auth\\SessionAuthBackend ) you can easily configure it in your DI module. <?php # /opt/my-app/MyAppModule.php namespace My\\App ; use Koded\\ { DIContainer , DIModule }; use Koded\\Framework\\Auth\\AuthBackend ; use My\\App\\Auth\\DatabaseAuth ; class MyAppModule implements DIModule { public function configure ( DIContainer $container ) : void { $container -> bind ( AuthBackend :: class , DatabaseAuth :: class ); } } Now register the module in the App constructor <?php # index.php new App ( modules : [ new MyAppModule ]); As you can see it's very easy to override anything in the Koded framework, including the default bindings.","title":"DI Modules"},{"location":"configure/modules/#dimodule-interface","text":"The purpose of this feature is to setup the DI container in your app. Once your app stops being \"Hello World\" and assuming you are going to follow some SOLID principles (or maybe not), the application may end up with lots of interfaces and concrete implementations. All of them can be mapped in the app module. Koded Container supports multiple modules, but one is sufficient for the container's configuration. Again, it is up to you how you are going to structure the application, so sometimes it makes sense to create multiple modules. Lets say you want to provide a database for the auth backend instance. Because Koded already has one registered by default ( Koded\\Framework\\Auth\\SessionAuthBackend ) you can easily configure it in your DI module. <?php # /opt/my-app/MyAppModule.php namespace My\\App ; use Koded\\ { DIContainer , DIModule }; use Koded\\Framework\\Auth\\AuthBackend ; use My\\App\\Auth\\DatabaseAuth ; class MyAppModule implements DIModule { public function configure ( DIContainer $container ) : void { $container -> bind ( AuthBackend :: class , DatabaseAuth :: class ); } } Now register the module in the App constructor <?php # index.php new App ( modules : [ new MyAppModule ]); As you can see it's very easy to override anything in the Koded framework, including the default bindings.","title":"DIModule interface"},{"location":"middleware/builtin/","text":"Built-in middlewares \u00b6 Out of the box Koded offers a curated list with common middleware functionality. The developers are encouraged to create their own (or use existing) PSR-15 middlewares to enhance the application features. CorsMiddleware \u00b6 ( loaded by default ) Cross-Origin Request Sharing support for your JavaScript applications. Please check the CORS middleware page to customize the behaviour of this middleware class. GzipMiddleware \u00b6 ( loaded by default ) Compresses the response payload with gzencode . AuthMiddleware \u00b6 A basic mechanism to run the auth logic. Supports the Authorization header. CallableMiddleware \u00b6 Used internally by the framework to support closures for the responders, or any PHP callable resource. HSTSMiddleware \u00b6 HTTP Strict Transport Security (HSTS). Redirects the request URI from HTTP to HTTPS. NoCacheMiddleware \u00b6 Adds no-cache response headers. XPoweredByMiddleware \u00b6 Sets the X-Powered-By response header.","title":"Built-in"},{"location":"middleware/builtin/#built-in-middlewares","text":"Out of the box Koded offers a curated list with common middleware functionality. The developers are encouraged to create their own (or use existing) PSR-15 middlewares to enhance the application features.","title":"Built-in middlewares"},{"location":"middleware/builtin/#corsmiddleware","text":"( loaded by default ) Cross-Origin Request Sharing support for your JavaScript applications. Please check the CORS middleware page to customize the behaviour of this middleware class.","title":"CorsMiddleware"},{"location":"middleware/builtin/#gzipmiddleware","text":"( loaded by default ) Compresses the response payload with gzencode .","title":"GzipMiddleware"},{"location":"middleware/builtin/#authmiddleware","text":"A basic mechanism to run the auth logic. Supports the Authorization header.","title":"AuthMiddleware"},{"location":"middleware/builtin/#callablemiddleware","text":"Used internally by the framework to support closures for the responders, or any PHP callable resource.","title":"CallableMiddleware"},{"location":"middleware/builtin/#hstsmiddleware","text":"HTTP Strict Transport Security (HSTS). Redirects the request URI from HTTP to HTTPS.","title":"HSTSMiddleware"},{"location":"middleware/builtin/#nocachemiddleware","text":"Adds no-cache response headers.","title":"NoCacheMiddleware"},{"location":"middleware/builtin/#xpoweredbymiddleware","text":"Sets the X-Powered-By response header.","title":"XPoweredByMiddleware"},{"location":"middleware/cors/","text":"CORS middleware \u00b6 Use the configuration to set the desired behavior of your application CORS middleware. # config.php <?php return [ 'cors.origin' => '' , 'cors.methods' => '' , 'cors.headers' => '' , 'cors.expose' => 'Authorization, X-Forwarded-With' , 'cors.maxAge' => 0 , 'cors.disable' => false , ... ]; Configuration directives \u00b6 CORS config directives will set the global behavior of the middleware. For example, if cors.methods has a value of GET, POST then only these two methods are allowed for all CORS requests . The same applies to all settings. Directive Type Default cors.origin string (empty) The server origin address as in schema://host:port (if the port is not a standard port) cors.methods string (empty) Comma-separated list of supported HTTP methods cors.headers string (empty) Comma-separated list of supported headers cors.expose string Authorization, X-Forwarded-With Comma-separated list of exposed headers cors.maxAge int 0 max-age header for OPTIONS request (before the actual request is called) cors.disable bool false This directive will completely disable the middleware","title":"Cors"},{"location":"middleware/cors/#cors-middleware","text":"Use the configuration to set the desired behavior of your application CORS middleware. # config.php <?php return [ 'cors.origin' => '' , 'cors.methods' => '' , 'cors.headers' => '' , 'cors.expose' => 'Authorization, X-Forwarded-With' , 'cors.maxAge' => 0 , 'cors.disable' => false , ... ];","title":"CORS middleware"},{"location":"middleware/cors/#configuration-directives","text":"CORS config directives will set the global behavior of the middleware. For example, if cors.methods has a value of GET, POST then only these two methods are allowed for all CORS requests . The same applies to all settings. Directive Type Default cors.origin string (empty) The server origin address as in schema://host:port (if the port is not a standard port) cors.methods string (empty) Comma-separated list of supported HTTP methods cors.headers string (empty) Comma-separated list of supported headers cors.expose string Authorization, X-Forwarded-With Comma-separated list of exposed headers cors.maxAge int 0 max-age header for OPTIONS request (before the actual request is called) cors.disable bool false This directive will completely disable the middleware","title":"Configuration directives"},{"location":"middleware/psr-15/","text":"Middleware stack \u00b6 The PSR-15 method signature for processing the incoming server request is very simple: process(request, handler): response request is the server side incoming request object, handler is the object that receive the request, do some work and returns a response . It is important to keep in mind when creating a custom middleware class for your app, where the processing of the ServerRequestInterface and ResponseInterface instances will take place. Workflow \u00b6 It is an \"onion layer\". request MW1 (request) MW2 (request) MW3 (request) ((RESOURCE)) MW3 (response) MW2 (response) MW1 (response) response when request object ( ServerRequestInterface ) is passed into the first middleware in the stack, it propagates forward through all middleware classes by modifying the instance, up to the point where the middleware classes are exhausted, then request object enters the Resource at this point the request object has been modified by all middleware classes in the stack once the Resource object return the ResponseInterface instance, it continue to propagate backwards through the middleware stack, now modifying the response object and finally response exits the middleware stack, to be processed by the Koded renderer and sent back to the caller (ex. browser) Example \u00b6 <?php namespace My\\App\\Middleware ; use Psr\\Http\\Message\\ { ResponseInterface , ServerRequestInterface }; use Psr\\Http\\Server\\ { MiddlewareInterface , RequestHandlerInterface }; class MyMiddleware implements MiddlewareInterface { public function process ( ServerRequestInterface $request , RequestHandlerInterface $handler ) : ResponseInterface { // --> Everything here is about the $request object $response = $handler -> handle ( $request ); // <-- Everything here is about the $response object return $response ; } } Lets set a random string for the request and pass it in the response header: <?php namespace My\\App\\Middleware ; use Psr\\Http\\Message\\ { ResponseInterface , ServerRequestInterface }; use Psr\\Http\\Server\\ { MiddlewareInterface , RequestHandlerInterface }; class RequestIdMiddleware implements MiddlewareInterface { public function process ( ServerRequestInterface $request , RequestHandlerInterface $handler ) : ResponseInterface { $request = $request -> withAttribute ( 'req-id' , bin2hex ( random_bytes ( 8 ))); // [NOTE]: the next middleware (or the resource object) // will have the ID in the request \"attributes\" property $response = $handler -> handle ( $request ); return $response -> withHeader ( 'X-Req-ID' , $request -> getAttribute ( 'req-id' )); } }","title":"PSR-15"},{"location":"middleware/psr-15/#middleware-stack","text":"The PSR-15 method signature for processing the incoming server request is very simple: process(request, handler): response request is the server side incoming request object, handler is the object that receive the request, do some work and returns a response . It is important to keep in mind when creating a custom middleware class for your app, where the processing of the ServerRequestInterface and ResponseInterface instances will take place.","title":"Middleware stack"},{"location":"middleware/psr-15/#workflow","text":"It is an \"onion layer\". request MW1 (request) MW2 (request) MW3 (request) ((RESOURCE)) MW3 (response) MW2 (response) MW1 (response) response when request object ( ServerRequestInterface ) is passed into the first middleware in the stack, it propagates forward through all middleware classes by modifying the instance, up to the point where the middleware classes are exhausted, then request object enters the Resource at this point the request object has been modified by all middleware classes in the stack once the Resource object return the ResponseInterface instance, it continue to propagate backwards through the middleware stack, now modifying the response object and finally response exits the middleware stack, to be processed by the Koded renderer and sent back to the caller (ex. browser)","title":"Workflow"},{"location":"middleware/psr-15/#example","text":"<?php namespace My\\App\\Middleware ; use Psr\\Http\\Message\\ { ResponseInterface , ServerRequestInterface }; use Psr\\Http\\Server\\ { MiddlewareInterface , RequestHandlerInterface }; class MyMiddleware implements MiddlewareInterface { public function process ( ServerRequestInterface $request , RequestHandlerInterface $handler ) : ResponseInterface { // --> Everything here is about the $request object $response = $handler -> handle ( $request ); // <-- Everything here is about the $response object return $response ; } } Lets set a random string for the request and pass it in the response header: <?php namespace My\\App\\Middleware ; use Psr\\Http\\Message\\ { ResponseInterface , ServerRequestInterface }; use Psr\\Http\\Server\\ { MiddlewareInterface , RequestHandlerInterface }; class RequestIdMiddleware implements MiddlewareInterface { public function process ( ServerRequestInterface $request , RequestHandlerInterface $handler ) : ResponseInterface { $request = $request -> withAttribute ( 'req-id' , bin2hex ( random_bytes ( 8 ))); // [NOTE]: the next middleware (or the resource object) // will have the ID in the request \"attributes\" property $response = $handler -> handle ( $request ); return $response -> withHeader ( 'X-Req-ID' , $request -> getAttribute ( 'req-id' )); } }","title":"Example"},{"location":"routing/","text":"The Router \u00b6 URI routing in Koded is easy. When dealing with routes keep in mind the following the router does not care about the HTTP method for the endpoint (this is resolved internally by the App instance) the HTTP method for the route (endpoint) is implemented in the resource object (or function) this framework does not offer a \"Route\" object parsed URI parameters are stored in the Psr\\Http\\Message\\ServerRequestInterface@attributes with their corresponding name => value pairs all routes are cached for better performance Routes are implemented in your execution script(s), ie. index.php , or any other PHP file that is part of the HTTP request/URI. route() method \u00b6 <?php public function route ( string $uriTemplate , object | string $resource , array $middleware = [], bool $explicit = false ) : App ; $uriTemplate \u00b6 REQUIRED - a route string that should match the request URI. See URI parameters how to deal with named variables in the URI template. The parameters are optional, you can normally set direct links, ie. <?php $app -> route ( '/about' , About :: class ); $resource \u00b6 REQUIRED - your resolver class (aka resource) where the matching HTTP methods are implemented. This argument can be a FQCN, an instance of a class, a \\Closure , or PHP callable. <?php $app -> route ( '/one' , ResourceOne :: class ) -> route ( '/two' , new ResourceTwo ) -> route ( '/three' , function ( Request $req , Response $res ) : Response { // ... }) -> route ( '/four' , 'ResourceFour::methodName' ) -> route ( '/five' , 'some_function' ) $middleware \u00b6 is a list of middleware classes/objects for this particular route. This argument solves the need to attach any functionalities with middlewares to the route. A good example is to provide an AuthMiddleware to protect the route(s) with authentication/authorization logic: <?php $app -> route ( '/protected' , Resource :: class , [ AuthMiddleware :: class ]); $explicit \u00b6 if set to TRUE it will override the global middleware stack ( App::$middleware ) and use only the middlewares in the $middleware list. In this example no middleware runs for this route, because $explicit = true and the $middleware = [] is empty: <?php $app -> route ( '/' , Resource :: class , [], true ); group() method \u00b6 This method adds a prefix to all routes in the $routes list. <?php public function group ( string $prefix , array $routes , array $middleware = []) : App ; $prefix \u00b6 this prefix is prepended to all $uriTemplate strings in the $routes list <?php $app -> group ( '/v2' , [ [ '/read' , Resource :: class ], [ '/edit' , Resource :: class ], [ '/add' , Resource :: class ], [ '/delete' , Resource :: class ], ]); /* * results in: * * /v2/read * /v2/edit * /v2/add * /v2/delete */ $routes \u00b6 is a list of routes arrays where the array elements must match the route() signature. $middleware \u00b6 This list of middlewares is an additional list that is merged with each route in the $routes list and differ from the $middleware list in the route method in this manner.","title":"Basics"},{"location":"routing/#the-router","text":"URI routing in Koded is easy. When dealing with routes keep in mind the following the router does not care about the HTTP method for the endpoint (this is resolved internally by the App instance) the HTTP method for the route (endpoint) is implemented in the resource object (or function) this framework does not offer a \"Route\" object parsed URI parameters are stored in the Psr\\Http\\Message\\ServerRequestInterface@attributes with their corresponding name => value pairs all routes are cached for better performance Routes are implemented in your execution script(s), ie. index.php , or any other PHP file that is part of the HTTP request/URI.","title":"The Router"},{"location":"routing/#route-method","text":"<?php public function route ( string $uriTemplate , object | string $resource , array $middleware = [], bool $explicit = false ) : App ;","title":"route() method"},{"location":"routing/#uritemplate","text":"REQUIRED - a route string that should match the request URI. See URI parameters how to deal with named variables in the URI template. The parameters are optional, you can normally set direct links, ie. <?php $app -> route ( '/about' , About :: class );","title":"$uriTemplate"},{"location":"routing/#resource","text":"REQUIRED - your resolver class (aka resource) where the matching HTTP methods are implemented. This argument can be a FQCN, an instance of a class, a \\Closure , or PHP callable. <?php $app -> route ( '/one' , ResourceOne :: class ) -> route ( '/two' , new ResourceTwo ) -> route ( '/three' , function ( Request $req , Response $res ) : Response { // ... }) -> route ( '/four' , 'ResourceFour::methodName' ) -> route ( '/five' , 'some_function' )","title":"$resource"},{"location":"routing/#middleware","text":"is a list of middleware classes/objects for this particular route. This argument solves the need to attach any functionalities with middlewares to the route. A good example is to provide an AuthMiddleware to protect the route(s) with authentication/authorization logic: <?php $app -> route ( '/protected' , Resource :: class , [ AuthMiddleware :: class ]);","title":"$middleware"},{"location":"routing/#explicit","text":"if set to TRUE it will override the global middleware stack ( App::$middleware ) and use only the middlewares in the $middleware list. In this example no middleware runs for this route, because $explicit = true and the $middleware = [] is empty: <?php $app -> route ( '/' , Resource :: class , [], true );","title":"$explicit"},{"location":"routing/#group-method","text":"This method adds a prefix to all routes in the $routes list. <?php public function group ( string $prefix , array $routes , array $middleware = []) : App ;","title":"group() method"},{"location":"routing/#prefix","text":"this prefix is prepended to all $uriTemplate strings in the $routes list <?php $app -> group ( '/v2' , [ [ '/read' , Resource :: class ], [ '/edit' , Resource :: class ], [ '/add' , Resource :: class ], [ '/delete' , Resource :: class ], ]); /* * results in: * * /v2/read * /v2/edit * /v2/add * /v2/delete */","title":"$prefix"},{"location":"routing/#routes","text":"is a list of routes arrays where the array elements must match the route() signature.","title":"$routes"},{"location":"routing/#middleware_1","text":"This list of middlewares is an additional list that is merged with each route in the $routes list and differ from the $middleware list in the route method in this manner.","title":"$middleware"},{"location":"routing/caching/","text":"The caching for routes is the same as for anything else and it is a \"global\" application caching. Setup cache \u00b6 Caching configuration is done by setting up the configuration for the App instance. Cache invalidation \u00b6 At this time there are no tools or a mechanism to invalidate the router cache.","title":"Routes caching"},{"location":"routing/caching/#setup-cache","text":"Caching configuration is done by setting up the configuration for the App instance.","title":"Setup cache"},{"location":"routing/caching/#cache-invalidation","text":"At this time there are no tools or a mechanism to invalidate the router cache.","title":"Cache invalidation"},{"location":"routing/parameters/","text":"URI parameters \u00b6 The URI parameters are named variables wrapped with curly braces {} in the URI template string. ->route('/{param1}/{param2}/{param3}/...') If the URI matches the route template, the values of the parameters will be stored in the Psr\\Http\\Message\\ServerRequestInterface@attributes and available through the request object with the getAttribute() method <?php public function put ( ServerRequestInterface $request ) { $param1 = $request -> getAttribute ( 'param1' ); $param2 = $request -> getAttribute ( 'param2' ); $param3 = $request -> getAttribute ( 'param3' ); ... } Parameter types \u00b6 The router supports simple types for automatic value typecasts. The values are strings by default str int float UUID path regex str \u00b6 ->route('/{id}') or ->route('/{id:str}') // ie. \"/123\" // the value is STRING ('id' => '123') int \u00b6 ->route('/{id:int}') // ie. \"/123\" // the value is INTEGER ('id' => 123) float \u00b6 ->route('/{lon:float}/{lat:float}') // ie. \"/41.9973/21.4325\" // the values are FLOATS ('lon' => 41.9973, 'lat' => 21.4325) UUID \u00b6 ->route('/{ident:UUID}') // ie. \"/7eacf466-321f-4ceb-914e-e525987e7804\" // the value is STRING ('ident' => '7eacf466-321f-4ceb-914e-e525987e7804') path \u00b6 ->route('/collection/{dir:path}') // ie. \"/collection/deeper/subgroup/name\" // the value is STRING ('dir' => 'deeper/subgroup/name') Only one :path parameter is supported regex \u00b6 ->route('/{something:regex:\\d+}') // ie. \"/123\" // 'something' => 123 Keep it simple Try to not overcomplicate your regular expressions, in most cases a simple type is sufficient.","title":"URI parameters"},{"location":"routing/parameters/#uri-parameters","text":"The URI parameters are named variables wrapped with curly braces {} in the URI template string. ->route('/{param1}/{param2}/{param3}/...') If the URI matches the route template, the values of the parameters will be stored in the Psr\\Http\\Message\\ServerRequestInterface@attributes and available through the request object with the getAttribute() method <?php public function put ( ServerRequestInterface $request ) { $param1 = $request -> getAttribute ( 'param1' ); $param2 = $request -> getAttribute ( 'param2' ); $param3 = $request -> getAttribute ( 'param3' ); ... }","title":"URI parameters"},{"location":"routing/parameters/#parameter-types","text":"The router supports simple types for automatic value typecasts. The values are strings by default str int float UUID path regex","title":"Parameter types"},{"location":"routing/parameters/#str","text":"->route('/{id}') or ->route('/{id:str}') // ie. \"/123\" // the value is STRING ('id' => '123')","title":"str"},{"location":"routing/parameters/#int","text":"->route('/{id:int}') // ie. \"/123\" // the value is INTEGER ('id' => 123)","title":"int"},{"location":"routing/parameters/#float","text":"->route('/{lon:float}/{lat:float}') // ie. \"/41.9973/21.4325\" // the values are FLOATS ('lon' => 41.9973, 'lat' => 21.4325)","title":"float"},{"location":"routing/parameters/#uuid","text":"->route('/{ident:UUID}') // ie. \"/7eacf466-321f-4ceb-914e-e525987e7804\" // the value is STRING ('ident' => '7eacf466-321f-4ceb-914e-e525987e7804')","title":"UUID"},{"location":"routing/parameters/#path","text":"->route('/collection/{dir:path}') // ie. \"/collection/deeper/subgroup/name\" // the value is STRING ('dir' => 'deeper/subgroup/name') Only one :path parameter is supported","title":"path"},{"location":"routing/parameters/#regex","text":"->route('/{something:regex:\\d+}') // ie. \"/123\" // 'something' => 123 Keep it simple Try to not overcomplicate your regular expressions, in most cases a simple type is sufficient.","title":"regex"},{"location":"translation/","text":"I18n setup \u00b6 The world is multilingual and Koded provides a simple I18n implementation. Translation strings are stored on a disk, processed by a \"catalog\" and accessed with translation function __() . <?php function __ ( string $string , array $arguments = [], string $locale = I18nCatalog :: DEFAULT_LOCALE ) : string Configuration \u00b6 I18n is set in the Koded DIModule and defaults to DefaultCatalog and DefaultFormatter Both can be changed in your app configuration: <?php return [ 'translation.catalog' => \\Koded\\Framework\\I18n\\GettextCatalog :: class , 'translation.formatter' => \\Koded\\Framework\\I18n\\StrtrFormatter :: class , 'translation.dir' => __DIR__ . '/locales/' , 'translation.locale' => 'mk_MK' , ];","title":"Setup"},{"location":"translation/#i18n-setup","text":"The world is multilingual and Koded provides a simple I18n implementation. Translation strings are stored on a disk, processed by a \"catalog\" and accessed with translation function __() . <?php function __ ( string $string , array $arguments = [], string $locale = I18nCatalog :: DEFAULT_LOCALE ) : string","title":"I18n setup"},{"location":"translation/#configuration","text":"I18n is set in the Koded DIModule and defaults to DefaultCatalog and DefaultFormatter Both can be changed in your app configuration: <?php return [ 'translation.catalog' => \\Koded\\Framework\\I18n\\GettextCatalog :: class , 'translation.formatter' => \\Koded\\Framework\\I18n\\StrtrFormatter :: class , 'translation.dir' => __DIR__ . '/locales/' , 'translation.locale' => 'mk_MK' , ];","title":"Configuration"},{"location":"translation/catalogs/","text":"Storages for translation strings \u00b6 Koded offers two different catalogs out of the box GettextCatalog DefaultCatalog Both are doing the same thing and the difference is how the translated strings are stored. Which one to use? GettextCatalog for projects with lots of languages (therefore lots of translators). DefaultCatalog for simple projects or relatively small amount of strings or languages support. There is no right or wrong choice, just pick one that you think is easy to work with or is suitable for your project. DefaultCatalog \u00b6 The strings are stored in the /locales/ application directory in a .php file with a locale name locales \u251c\u2500\u2500 de_DE.php \u251c\u2500\u2500 en_US.php \u2514\u2500\u2500 mk_MK.php etc. The structure for the en_US.php translation file is <?php return [ 'language' => 'English' , 'messages' => [ ] ]; and all locales are expected to be of the same format. Examples \u00b6 # locales/en_US.php <?php return [ 'language' => 'English' , 'messages' => [ 'original string' => 'translated string' , 'pagination.pages' => 'page {0} of {1}' , ] ]; # somewhere in your code __ ( 'original string' ) // outputs: \"translated string\" __ ( 'pagination.pages' , [ 1 , 42 ]) // outputs: \"page 1 of 42\" GettextCatalog \u00b6 This catalog requires the gettext PHP extension and uses the excellent translation functionality provided by it. The strings are stored in .po/.mo files within a proper directory structure: locales \u2514\u2500\u2500 en_US \u2514\u2500\u2500 LC_MESSAGES \u251c\u2500\u2500 messages.mo \u2514\u2500\u2500 messages.po etc. The recommended translation editor is Poedit that supports this kind of translations.","title":"Catalogs"},{"location":"translation/catalogs/#storages-for-translation-strings","text":"Koded offers two different catalogs out of the box GettextCatalog DefaultCatalog Both are doing the same thing and the difference is how the translated strings are stored. Which one to use? GettextCatalog for projects with lots of languages (therefore lots of translators). DefaultCatalog for simple projects or relatively small amount of strings or languages support. There is no right or wrong choice, just pick one that you think is easy to work with or is suitable for your project.","title":"Storages for translation strings"},{"location":"translation/catalogs/#defaultcatalog","text":"The strings are stored in the /locales/ application directory in a .php file with a locale name locales \u251c\u2500\u2500 de_DE.php \u251c\u2500\u2500 en_US.php \u2514\u2500\u2500 mk_MK.php etc. The structure for the en_US.php translation file is <?php return [ 'language' => 'English' , 'messages' => [ ] ]; and all locales are expected to be of the same format.","title":"DefaultCatalog"},{"location":"translation/catalogs/#examples","text":"# locales/en_US.php <?php return [ 'language' => 'English' , 'messages' => [ 'original string' => 'translated string' , 'pagination.pages' => 'page {0} of {1}' , ] ]; # somewhere in your code __ ( 'original string' ) // outputs: \"translated string\" __ ( 'pagination.pages' , [ 1 , 42 ]) // outputs: \"page 1 of 42\"","title":"Examples"},{"location":"translation/catalogs/#gettextcatalog","text":"This catalog requires the gettext PHP extension and uses the excellent translation functionality provided by it. The strings are stored in .po/.mo files within a proper directory structure: locales \u2514\u2500\u2500 en_US \u2514\u2500\u2500 LC_MESSAGES \u251c\u2500\u2500 messages.mo \u2514\u2500\u2500 messages.po etc. The recommended translation editor is Poedit that supports this kind of translations.","title":"GettextCatalog"},{"location":"translation/formatters/","text":"Formatters \u00b6 String formatters are used to replace the translation arguments provided in the __(string, arguments) function. The default formatter is DefaultFormatter and it's set in the Koded DIModule . Choose one Once you start with translations, the format of the strings with arguments matters, because the argument replacement is different for DefaultFormatter and StrtrFormatter . DefaultFormatter \u00b6 This formatter uses the vsprintf PHP function to replace the string arguments with values. StrtrFormatter \u00b6 This formatter uses the strtr PHP function to replace the string arguments with values.","title":"Formatters"},{"location":"translation/formatters/#formatters","text":"String formatters are used to replace the translation arguments provided in the __(string, arguments) function. The default formatter is DefaultFormatter and it's set in the Koded DIModule . Choose one Once you start with translations, the format of the strings with arguments matters, because the argument replacement is different for DefaultFormatter and StrtrFormatter .","title":"Formatters"},{"location":"translation/formatters/#defaultformatter","text":"This formatter uses the vsprintf PHP function to replace the string arguments with values.","title":"DefaultFormatter"},{"location":"translation/formatters/#strtrformatter","text":"This formatter uses the strtr PHP function to replace the string arguments with values.","title":"StrtrFormatter"},{"location":"utils/caching/","text":"Application caching (PSR-16) \u00b6 The (app) caching is bolted-in and always on. The default cache library is Koded Simple Cache . Application caching The cache functionality is available in the user app by simply demanding an instance of PSR-16 Psr\\SimpleCache\\CacheInterface instance. The DI container will inject the configured cache client. <?php ... public function something ( CacheInterface $cache ) { // ... } ... Setup cache \u00b6 Caching configuration is done in the application configuration for the App instance. <?php return [ 'caching' => [ // ] ]; <?php new App ( config : 'config.php' ); Memory \u00b6 Default cache is Memory and does not require a special treatment. It will provide caching for the duration of the request which is useful for development and unit testing. Memory (default) No need to set anything in the configuration. This is the default caching client.","title":"Caching"},{"location":"utils/caching/#application-caching-psr-16","text":"The (app) caching is bolted-in and always on. The default cache library is Koded Simple Cache . Application caching The cache functionality is available in the user app by simply demanding an instance of PSR-16 Psr\\SimpleCache\\CacheInterface instance. The DI container will inject the configured cache client. <?php ... public function something ( CacheInterface $cache ) { // ... } ...","title":"Application caching (PSR-16)"},{"location":"utils/caching/#setup-cache","text":"Caching configuration is done in the application configuration for the App instance. <?php return [ 'caching' => [ // ] ]; <?php new App ( config : 'config.php' );","title":"Setup cache"},{"location":"utils/caching/#memory","text":"Default cache is Memory and does not require a special treatment. It will provide caching for the duration of the request which is useful for development and unit testing. Memory (default) No need to set anything in the configuration. This is the default caching client.","title":"Memory"},{"location":"utils/logger/","text":"Logging (PSR-5) \u00b6 Default logging library is Koded Logging . Logging Demand an instance of PSR-5 Psr\\Log\\LoggerInterface in your methods, DI container will inject the configured log instance. <?php ... public function something ( LoggerInterface $log ) { // ... } ... Setup logging \u00b6 Logger library is configured in the \\ application configuration for the App instance. <?php return [ 'logging' => [ 'timezone' => 'UTC' , 'dateformat' => 'Y-m-d H:i:s.u' 'loggers' => [ [ 'class' => \\Koded\\Logging\\Processors\\Cli :: class , 'format' => '[levelname] message' , 'levels' => - 1 ] ] ], ]; The conf key loggers is a list of Koded\\Logging\\Log log processor implementations. By default only one log processor is registered that processes all log levels.","title":"Logging"},{"location":"utils/logger/#logging-psr-5","text":"Default logging library is Koded Logging . Logging Demand an instance of PSR-5 Psr\\Log\\LoggerInterface in your methods, DI container will inject the configured log instance. <?php ... public function something ( LoggerInterface $log ) { // ... } ...","title":"Logging (PSR-5)"},{"location":"utils/logger/#setup-logging","text":"Logger library is configured in the \\ application configuration for the App instance. <?php return [ 'logging' => [ 'timezone' => 'UTC' , 'dateformat' => 'Y-m-d H:i:s.u' 'loggers' => [ [ 'class' => \\Koded\\Logging\\Processors\\Cli :: class , 'format' => '[levelname] message' , 'levels' => - 1 ] ] ], ]; The conf key loggers is a list of Koded\\Logging\\Log log processor implementations. By default only one log processor is registered that processes all log levels.","title":"Setup logging"}]}