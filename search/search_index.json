{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Koded Web Framework","text":""},{"location":"#why","title":"Why?","text":"<p>Sometimes we want a prototype, or quick/simple operations, or solutions for building fast web APIs and app backends.  And having a full-blown frameworks will eventually weight you down with tons of unnecessary abstractions and dependencies.</p> <p>Koded offers small footprint with a clean design that follows the HTTP and ReST architectural style. It tends to be very fast  and easy to work with.</p>"},{"location":"#minimum-application","title":"Minimum application","text":"<pre><code>&lt;?php\nuse Koded\\Framework\\App;\nuse Koded\\Http\\ServerResponse as R;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n((new App)\n    -&gt;route('/', fn() =&gt; new R('Hello'))\n)();\n</code></pre> <p>This fits in a tweet.</p>"},{"location":"#resource-method-representation","title":"Resource Method Representation","text":"<p>Koded Framework follows the RMR web architectural pattern, but the developer is free to use whatever it prefers and does  not enforce any programming patterns in the application.</p> <p>However, it is strongly recommended adopting and using RMR  because it is aligned nicely with the HTTP ReST concepts. After all, web apps needs fundamental directions and principles, not \"perfect\" solutions so RMR fits here very well.</p> Resource <p>An object in the RESTful system identified by a URL that exposes methods that corresponds to the standard HTTP methods (GET, POST, PUT, etc) i.e. a business object (entity).</p> Method <p>The HTTP request method that corresponds a Resource method that is executed by the request/URL, which returns a Representation for that resource.</p> Representation <p>Provides a Resource to clients in a readable format (JSON, XML, PDF, HTML, etc). It is the payload of the response object (processed by the HTTP Method  that is sent back to the client).</p>"},{"location":"default-dependencies/","title":"Default framework dependencies","text":""},{"location":"default-dependencies/#framework-di-module","title":"Framework DI module","text":"<p>It loads the following dependencies by default:</p>"},{"location":"default-dependencies/#interfaces","title":"Interfaces","text":"<p>See implementations and shared instances.</p>"},{"location":"default-dependencies/#http","title":"HTTP","text":"<ul> <li>PSR-7 <code>Psr\\Http\\Message\\ServerRequestInterface</code></li> <li>PSR-7 <code>Psr\\Http\\Message\\ResponseInterface</code></li> <li><code>Koded\\Framework\\Request</code></li> <li><code>Koded\\Framework\\Response</code></li> </ul>"},{"location":"default-dependencies/#authentication","title":"Authentication","text":"<ul> <li> <p><code>Framework\\Auth\\AuthBackend</code></p> <p>Used in the AuthMiddleware  - <code>Framework\\Auth\\AuthProcessor</code></p> <p>Executes the <code>authenticate()</code> in the AuthMiddleware</p> </li> </ul> <p>Application should override the <code>AuthBackend</code> to provide its own authentication storage and logic (i.e. database).</p> <p>The <code>AuthProcessor</code> parses the credentials and may be overridden to support different types of auth mechanisms (i.e. JWT)</p>"},{"location":"default-dependencies/#utility","title":"Utility","text":"<ul> <li>PSR-16 <code>Psr\\SimpleCache\\CacheInterface</code></li> <li>PSR-3 <code>Psr\\Log\\LoggerInterface</code></li> <li><code>Koded\\Stdlib\\Configuration</code></li> </ul>"},{"location":"default-dependencies/#middleware","title":"Middleware","text":"<p>Koded uses PSR-15 middlewares. More details on the middleware page</p>"},{"location":"default-dependencies/#bindings","title":"Bindings","text":"<p>Anything that's bound by the default DI module can be replaced with custom implementation(s) in your application DI module(s). The default classes are from the Koded libraries.</p>"},{"location":"exception-handlers/","title":"Exception handling","text":"<p>By default, the following exceptions are caught and handled</p> <ul> <li><code>\\Exception</code></li> <li><code>\\Error</code></li> <li><code>Koded\\Http\\HTTPError</code></li> </ul> <p>The error response payload follows the RFC-7807 specification.</p> <p>If you wish to capture specific exception types and/or return custom  error messages, create your own class and register it with the method  <code>App::withErrorHandler()</code> to convert the exceptions into the desired HTTP responses.</p> <p>handle() method signature</p> <p><code>handle(request, response, exception): void</code></p> <p>If app does not use 3rd party PSR-7 library, then Koded will use its  own implementations from the Koded HTTP library.</p> <pre><code>&lt;?php\n\n# CustomExceptionHandler.php\n\nuse Koded\\Framework\\App;\nuse Koded\\Http\\HTTPError;\nuse Koded\\Http\\Interfaces\\{Request, Response};\n\nclass CustomExceptionHandler {\n\n    public static function handle(\n        Request $request,\n        Response $response,\n        HTTPError $exception): void\n    {\n        // do something with $exception\n        // i.e. re-format the error message and set it in the response\n    }\n}\n</code></pre>"},{"location":"exception-handlers/#register-handler","title":"Register handler","text":"<p>Register before routes</p> <p>Order matters. It is required to register the custom  exception handlers BEFORE the routes, otherwise they  won't be handled if the request/route has been resolved.</p> <pre><code>&lt;?php\n\n# index.php\n\n((new App)\n    -&gt;withErrorHandler(CustomExceptionHandler::class)\n    -&gt;route(/* ... */)\n)();\n</code></pre> <p>This implementation is using a  PSR-7 compatible  library and a standard PHP <code>Throwable</code> class.</p> <pre><code>&lt;?php\n\nuse Psr\\Http\\Message\\{ServerRequestInterface, ResponseInterface};\n\nclass PDOExceptionHandler {\n\n    public static function handle(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        \\Throwable $exception): void\n    {\n        if ($exception instanceof \\PDOException) {\n            // do something about it\n        }\n    }\n}\n</code></pre>"},{"location":"exception-handlers/#unregister-handler","title":"Unregister handler","text":"<p>Use <code>App::withoutErrorHandler()</code> method to remove the error handler.</p> <p>Unregister after custom handlers</p> <p>Order matters. Unregister the exception handlers AFTER the custom registration, otherwise they won't be removed.</p> <pre><code>&lt;?php\n\n# index.php\n\n((new App)\n    -&gt;withErrorHandler(SomeCustomErrorHandler::class)\n\n    -&gt;withoutErrorHandler(AnotherCustomExceptionHandler::class)\n    -&gt;route(/* ... */)\n)();\n</code></pre>"},{"location":"get-started/","title":"Requirements","text":""},{"location":"get-started/#installation","title":"Installation","text":""},{"location":"get-started/#using-composer","title":"Using composer","text":"<pre><code>composer require koded/framework\n</code></pre> <p>No composer?</p> <p>If you don't have <code>composer</code> please follow the download instructions how to install it on your OS.</p> <p>For manual install on Linux you may run this command:</p> <pre><code>curl https://getcomposer.org/download/latest-stable/composer.phar -o /usr/local/bin/composer \\\n    &amp;&amp; chmod +x /usr/local/bin/composer\n</code></pre>"},{"location":"get-started/#app-basics","title":"App basics","text":""},{"location":"get-started/#files-structure","title":"Files structure","text":"<p>It is up to you how you're going to structure your project. A simple and clear structuring is essential for great development, on a long run (or short too), but that is up to developer needs,  or based on the app complexity, team decisions, or various other reasons.</p> <p>Let's look at something that is good in general as a startup,</p> <pre><code>app/\n    .env\nhtml/\n    .htaccess\n    index.php\nvendor/\ncomposer.json\n</code></pre> <p>Everything regarding your application goes into the <code>app/</code> folder. This is an example, <code>app</code> is not a requirement and it can be anything you want.</p> <p>Protect your code!</p> <p>It is important to keep everything outside the <code>html/</code> folder (<code>app/</code>, <code>vendor/</code> or anything that is app related and may expose the code). Make sure the app code is not accessible from the outside.</p>"},{"location":"get-started/#composerjson","title":"composer.json","text":"<p>A <code>composer.json</code> scaffold for your project. Run <code>composer update</code> every time a new class is added, or use <code>psr-4</code> in <code>autoload</code> section while you develop  the app, whatever you prefer most.</p> <pre><code>{\n    \"require\": {\n        \"koded/framework\": \"^1\"\n    },\n    \"autoload\": {\n      \"classmap\": [\n        \"app\"\n      ],\n      \"exclude-from-classmap\": [\n        \"html\"\n      ]\n    },\n    \"config\": {\n      \"optimize-autoloader\": true\n    }\n}\n</code></pre>"},{"location":"get-started/#docker-quick-example","title":"Docker (quick example)","text":"<p>You can jumpstart the development with <code>docker</code> and <code>docker-compose</code> with the above app file structure.</p> <pre><code># docker-compose.yaml\n\nversion: '3'\n\nservices:\n    php:\n        image: php:8-apache\n        ports:\n            - 8080:80\n        volumes:\n            - .:/var/www\n</code></pre> <p>Adjust the volumes, or the host port if it's already taken. Run <code>docker-compose up -d</code> and open your browser at <code>127.0.0.1:8080</code></p>"},{"location":"get-started/#app-entry-point","title":"App entry point","text":"<p>Create the \"entry script\" for all HTTP requests.  There we create an instance of <code>App</code> and define the URI routes.</p> <pre><code># /var/www/html/index.php\n\n&lt;?php\n\nuse Koded\\Framework\\App;\nuse Koded\\Http\\Interfaces\\Response;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n((new App)\n    -&gt;route('/', function(Response $response): Response {\n        $response-&gt;getBody()-&gt;write('Work In Progress...');\n        return $response;\n    })\n)();\n</code></pre> <p>Now point your browser to app address. It should print \"Work in Progress...\" with status code 200.</p> <p>From here on add more routes and resources to your API, but keep in mind that using closures as resources is NOT the recommended way to  build the application. For more on this please follow the documentation further.</p>"},{"location":"shared-instances/","title":"Shared instances","text":"spec interface default implementation PSR-3 <code>Psr\\Log\\LoggerInterface</code> <code>Koded\\Logging\\Log</code> PSR-16 <code>Psr\\SimpleCache\\CacheInterface</code> <code>Koded\\Caching\\Client\\MemoryClient</code> <code>Koded\\Stdlib\\Configuration</code> <code>Koded\\Stdlib\\Config</code> N/A <code>Koded\\Framework\\Router</code>"},{"location":"shared-instances/#default-bindings","title":"Default bindings","text":"spec interface default implementation PSR-7 <code>Psr\\Http\\Message\\ServerRequestInterface</code> <code>Koded\\Http\\ServerRequest</code> PSR-7 <code>Psr\\Http\\Message\\ResponseInterface</code> <code>Koded\\Http\\ServerResponse</code> PSR-7 <code>Koded\\Http\\Interfaces\\Request</code> <code>Koded\\Http\\ServerRequest</code> PSR-7 <code>Koded\\Http\\Interfaces\\Response</code> <code>Koded\\Http\\ServerResponse</code> <code>Koded\\Framework\\Auth\\AuthBackend</code> <code>Koded\\Framework\\Auth\\SessionAuthBackend</code> <code>Koded\\Framework\\Auth\\AuthProcessor</code> <code>Koded\\Framework\\Auth\\TokenAuthProcessor</code>"},{"location":"configure/","title":"App class configuration","text":"<p>The configuration object is created by setting the config directives in the <code>Koded\\Framework\\App</code> constructor.</p> Argument Type Required Default modules array no [] A list of DIModules for the app middleware array no [] The app middleware stack config object, string no '' A path to a config file, FQCN of the configuration class, or an instance of a config object renderer string no 'start_response' Response renderer function/method <p>All directives are optional.</p> <pre><code>&lt;?php\n\nnew App(\n    modules: [\n        // a list of DIModule implementation(s)\n    ],\n    middleware: [\n        // a list of PSR-15 middleware classes (global)\n    ],\n    config: __DIR__ . '/path/to/my/config.php', \n    // or\n    config: '.env', \n    // or\n    config: new MyConfig(),\n\n    renderer: MyRenderer::class,\n    // or\n    renderer: 'my_renderer_function'\n);\n</code></pre>"},{"location":"configure/#constructor-arguments","title":"Constructor arguments","text":""},{"location":"configure/#modules","title":"modules","text":"<p>optional</p> <p>This argument accepts a list of <code>DIModule</code> instances that  configures the Dependency Injection Container for your app. See more about DI modules.</p> <p>Example: <pre><code>[\n    new My\\App\\Module(),\n]\n</code></pre></p>"},{"location":"configure/#middleware","title":"middleware","text":"<p>optional</p> <p>A list of PSR-15 middleware classes for your application.</p> <p>Example: <pre><code>[\n    // ... your middleware classes\n    My\\App\\Middleware\\CustomMiddleware::class,\n    new My\\App\\Middleware\\Other(),\n]\n</code></pre></p> <p>Check the PSR-15 middleware stack page for details how Koded framework implements this functionality.</p>"},{"location":"configure/#config","title":"config","text":"<p>optional</p> <p>Configuration values for your application. It supports </p> <ul> <li><code>.php</code> file that returns an array, or </li> <li><code>.env</code> file, or </li> <li>instance of <code>Koded\\Stdlib\\Configuration</code> object.</li> </ul> <p>Examples:</p> <pre><code>&lt;?php\n\n# conf.php\nreturn [\n    'key' =&gt; 'value',\n];\n\n# /var/www/public/index.php\nnew App(config: '/path/to/conf.php');\n</code></pre> <pre><code># .env is always loaded (if exist)\nkey=value\n</code></pre> <pre><code>&lt;?php\nuse Koded\\Framework\\App;\nuse Koded\\Stdlib\\{Config, Immutable}\n\n$config = new Config('/path/to/app/dir', new Immutable([\n    'key' =&gt; 'value',\n]));\n\nnew App(config: $config);\n</code></pre> <p>.env support</p> <p>Make sure .env file is not accessible from the outside.</p>"},{"location":"configure/#renderer","title":"renderer","text":"<p>optional</p> <p>A custom renderer for the processed <code>ResponseInterface</code> object.  This method/function is executed by the DI container, meaning the  depencencies can be anything that the container is able to resolve.</p> <p>default <code>'start_response'</code> </p> <pre><code>&lt;?php\nnew App(renderer: MyCustomRenderer::class);\n\nnew App(renderer: 'My\\App\\custom_renderer');\n</code></pre> <p>The purpose of this class method (or function) is to provide a custom processing of the <code>ServerRequestInterface</code>  and <code>ResponseInterface</code> objects BEFORE it is finally sent to the client, for example a custom-made HTML renderer for server-side template engines, or a response streaming, etc.</p>"},{"location":"configure/modules/","title":"DIModule interface","text":"<pre><code>The purpose of this feature is to setup the DI container in your app.\n</code></pre> <p>Once your app stops being \"Hello World\" and assuming you are going to follow some SOLID principles (or maybe not), the application may end  up with lots of interfaces and concrete implementations. All of them  can be mapped in the app module.</p> <p>Koded Container  supports multiple modules, but one is sufficient for the container's configuration. Again, it is up to you how you are going to structure the application, so sometimes it makes sense to create multiple modules.</p> <p>Lets say you want to provide a database for the auth backend instance. Because Koded already has one registered by default (<code>Koded\\Framework\\Auth\\SessionAuthBackend</code>) you can easily configure it in your DI module.</p> <pre><code>&lt;?php\n\n# /opt/my-app/MyAppModule.php\n\nnamespace My\\App;\n\nuse Koded\\{DIContainer, DIModule};\nuse Koded\\Framework\\Auth\\AuthBackend;\nuse My\\App\\Auth\\DatabaseAuth;\n\nclass MyAppModule implements DIModule {\n\n    public function configure(DIContainer $container): void\n    {\n        $container-&gt;bind(AuthBackend::class, DatabaseAuth::class);\n    }\n}\n</code></pre> <p>Now register the module in the <code>App</code> constructor</p> <pre><code>&lt;?php\n\n# index.php\n\nnew App(modules: [new MyAppModule]);\n</code></pre> <p>As you can see it's very easy to override anything in the Koded framework, including the default bindings.</p>"},{"location":"middleware/builtin/","title":"Built-in middlewares","text":"<p>Out of the box Koded offers a curated list with  common middleware functionality. The developers are encouraged to create their own (or use existing) PSR-15 middlewares to enhance the application features.</p>"},{"location":"middleware/builtin/#corsmiddleware","title":"CorsMiddleware","text":"<p>(loaded by default) Cross-Origin Request Sharing support for your JavaScript  applications.</p> <p>Please check the CORS middleware page to customize the behaviour of this middleware class.</p>"},{"location":"middleware/builtin/#gzipmiddleware","title":"GzipMiddleware","text":"<p>(loaded by default) Compresses the response payload with <code>gzencode</code>.</p>"},{"location":"middleware/builtin/#authmiddleware","title":"AuthMiddleware","text":"<p>A basic mechanism to run the auth logic. Supports the <code>Authorization</code> header. </p>"},{"location":"middleware/builtin/#callablemiddleware","title":"CallableMiddleware","text":"<p>Used internally by the framework to support closures for the responders, or any <code>PHP callable</code> resource.</p>"},{"location":"middleware/builtin/#hstsmiddleware","title":"HSTSMiddleware","text":"<p>HTTP Strict Transport Security (HSTS). Redirects the request URI from HTTP to HTTPS.</p>"},{"location":"middleware/builtin/#nocachemiddleware","title":"NoCacheMiddleware","text":"<p>Adds no-cache response headers.</p>"},{"location":"middleware/builtin/#xpoweredbymiddleware","title":"XPoweredByMiddleware","text":"<p>Sets the <code>X-Powered-By</code> response header.</p>"},{"location":"middleware/cors/","title":"CORS middleware","text":"<p>Use the configuration to set the desired behavior of your application CORS middleware.</p> <pre><code># config.php\n\n&lt;?php\n\nreturn [\n  'cors.origin'  =&gt; '',\n  'cors.methods' =&gt; '',\n  'cors.headers' =&gt; '',\n  'cors.expose'  =&gt; 'Authorization, X-Forwarded-With',\n  'cors.maxAge'  =&gt; 0,\n  'cors.disable' =&gt; false,\n  ...\n];\n</code></pre>"},{"location":"middleware/cors/#configuration-directives","title":"Configuration directives","text":"<p>CORS config directives will set the global behavior of the middleware. For example, if <code>cors.methods</code> has a value of <code>GET, POST</code> then only these two methods are allowed for all CORS requests. The same applies to all settings.</p> Directive Type Default cors.origin string (empty) The server origin address as in <code>schema://host:port</code> (if the port is not a standard port) cors.methods string (empty) Comma-separated list of supported HTTP methods cors.headers string (empty) Comma-separated list of supported headers cors.expose string Authorization, X-Forwarded-With Comma-separated list of exposed headers cors.maxAge int 0 <code>max-age</code> header for OPTIONS request (before the actual request is called) cors.disable bool false This directive will completely disable the middleware"},{"location":"middleware/psr-15/","title":"Middleware stack","text":"<p>The PSR-15 method signature for processing  the incoming server request is very simple:</p> <pre><code>process(request, handler): response\n</code></pre> <p><code>request</code> is the server side incoming request object, <code>handler</code> is the object that receive the request, do some work and returns a <code>response</code>.</p> <p>It is important to keep in mind when creating a custom middleware class for your app, where the processing of the <code>ServerRequestInterface</code>  and <code>ResponseInterface</code> instances will take place.</p>"},{"location":"middleware/psr-15/#workflow","title":"Workflow","text":"<p>It is an \"onion layer\".</p> <pre><code>request\n    MW1 (request)\n        MW2 (request)\n            MW3 (request)\n                    ((RESOURCE))\n            MW3 (response)\n        MW2 (response)\n    MW1 (response)\nresponse\n</code></pre> <ol> <li> <p>when request object (<code>ServerRequestInterface</code>) is passed into the      first middleware in the stack, it propagates forward through all      middleware classes by modifying the instance,</p> </li> <li> <p>up to the point where the middleware classes are exhausted,      then request object enters the Resource</p> </li> <li> <p>at this point the request object has been modified      by all middleware classes in the stack</p> </li> <li> <p>once the <code>Resource</code> object return the <code>ResponseInterface</code> instance,     it continue to propagate backwards through the middleware stack,      now modifying the response object</p> </li> <li> <p>and finally response exits the middleware stack, to be processed      by the Koded renderer and sent back to the caller (ex. browser)</p> </li> </ol>"},{"location":"middleware/psr-15/#example","title":"Example","text":"<pre><code>&lt;?php\n\nnamespace My\\App\\Middleware;\n\nuse Psr\\Http\\Message\\{ResponseInterface, ServerRequestInterface};\nuse Psr\\Http\\Server\\{MiddlewareInterface, RequestHandlerInterface};\n\nclass MyMiddleware implements MiddlewareInterface {\n\n    public function process(\n        ServerRequestInterface $request, \n        RequestHandlerInterface $handler): ResponseInterface\n    {\n        // --&gt; Everything here is about the $request object\n\n        $response = $handler-&gt;handle($request);\n\n        // &lt;-- Everything here is about the $response object\n\n        return $response;\n    }\n}\n</code></pre> <p>Lets set a random string for the request and pass it in the response header:</p> <pre><code>&lt;?php\n\nnamespace My\\App\\Middleware;\n\nuse Psr\\Http\\Message\\{ResponseInterface, ServerRequestInterface};\nuse Psr\\Http\\Server\\{MiddlewareInterface, RequestHandlerInterface};\n\nclass RequestIdMiddleware implements MiddlewareInterface {\n\n    public function process(\n        ServerRequestInterface $request, \n        RequestHandlerInterface $handler): ResponseInterface\n    {\n        $request = $request\n            -&gt;withAttribute('req-id', bin2hex(random_bytes(8)));\n\n        // [NOTE]: the next middleware (or the resource object)\n        // will have the ID in the request \"attributes\" property \n\n        $response = $handler-&gt;handle($request);\n\n        return $response\n            -&gt;withHeader('X-Req-ID', $request-&gt;getAttribute('req-id'));\n    }\n}\n</code></pre>"},{"location":"routing/","title":"The Router","text":"<p>URI routing in Koded is easy. When dealing with routes keep in mind the following</p> <ul> <li>the router does not care about the HTTP method for the endpoint    (this is resolved internally by the <code>App</code> instance)</li> <li>the HTTP method for the route (endpoint) is implemented in the resource object (or function)</li> <li>this framework does not offer a \"Route\" object</li> <li>parsed URI parameters are stored in the <code>Psr\\Http\\Message\\ServerRequestInterface@attributes</code>     as <code>name =&gt; value</code> pairs</li> <li>all routes are cached for better performance</li> </ul> <p>Routes are implemented in your execution script(s), ie. <code>index.php</code>, or any other PHP file that is part of the HTTP request/URI.</p>"},{"location":"routing/#route-method","title":"route() method","text":"<pre><code>&lt;?php\n\npublic function route(\n  string $uriTemplate,\n  object|string $resource,\n  array $middleware = [],\n  bool $explicit = false): App;\n</code></pre>"},{"location":"routing/#uritemplate","title":"<code>$uriTemplate</code>","text":"<p>REQUIRED - a route string that should match the request URI.</p> <p>See URI parameters how to deal with named variables in the URI template.</p> <p>The parameters are optional, you can normally set direct links, ie.</p> <pre><code>&lt;?php\n$app-&gt;route('/about', About::class);\n</code></pre>"},{"location":"routing/#resource","title":"<code>$resource</code>","text":"<p>REQUIRED - your resolver class (aka resource) where the matching HTTP methods are implemented.</p> <p>This argument can be a FQCN, an instance of a class, a <code>\\Closure</code>, or PHP callable.</p> <pre><code>&lt;?php\n\n$app\n    -&gt;route('/one', ResourceOne::class)\n    -&gt;route('/two', new ResourceTwo)\n    -&gt;route('/three', function(Request $req, Response $res): Response {\n        // ...\n    })\n    -&gt;route('/four', 'ResourceFour::methodName')\n    -&gt;route('/five', 'some_function')\n</code></pre>"},{"location":"routing/#middleware","title":"<code>$middleware</code>","text":"<p>is a list of middleware classes/objects for this particular route.</p> <p>This argument solves the need to attach any functionalities  with middlewares to the route. A good example is to provide an <code>AuthMiddleware</code> to protect the route(s) with  authentication/authorization logic:</p> <pre><code>&lt;?php\n$app-&gt;route('/protected', Resource::class, [AuthMiddleware::class]);\n</code></pre>"},{"location":"routing/#explicit","title":"<code>$explicit</code>","text":"<p>if set to <code>TRUE</code> it will override the global middleware stack (<code>App::$middleware</code>) and use only the middlewares in the <code>$middleware</code> list.</p> <p>In this example no middleware runs for this route, because <code>$explicit = true</code> and the <code>$middleware = []</code> is empty:</p> <pre><code>&lt;?php\n$app-&gt;route('/', Resource::class, [], true);\n</code></pre>"},{"location":"routing/#group-method","title":"group() method","text":"<p>This method adds a prefix to all routes in the <code>$routes</code> list.</p> <pre><code>&lt;?php\n\npublic function group(\n  string $prefix,\n  array $routes,\n  array $middleware = []): App;\n</code></pre>"},{"location":"routing/#prefix","title":"<code>$prefix</code>","text":"<p>this prefix is prepended to all <code>$uriTemplate</code> strings in the <code>$routes</code> list <pre><code>&lt;?php\n\n$app-&gt;group('/v2', [\n    ['/read', Resource::class],\n    ['/edit', Resource::class],\n    ['/add', Resource::class],\n    ['/delete', Resource::class],\n]);\n\n/*\n * results in:\n * \n * /v2/read\n * /v2/edit\n * /v2/add\n * /v2/delete\n */\n</code></pre></p>"},{"location":"routing/#routes","title":"<code>$routes</code>","text":"<p>is a list of routes arrays where the array elements must match the <code>route()</code> signature.</p>"},{"location":"routing/#middleware_1","title":"<code>$middleware</code>","text":"<p>This list of middlewares is an additional list that is  merged with each route in the <code>$routes</code> list and differ from the  <code>$middleware</code> list in the route method in this manner.</p>"},{"location":"routing/caching/","title":"Routes caching","text":"<p>The caching for routes is the same as for anything else and it is a \"global\" application caching. </p>"},{"location":"routing/caching/#setup-cache","title":"Setup cache","text":"<p>Caching configuration is done by setting up the configuration for the <code>App</code> instance.</p>"},{"location":"routing/caching/#cache-invalidation","title":"Cache invalidation","text":"<p>At this time there are no tools or a mechanism to invalidate the router cache.</p>"},{"location":"routing/parameters/","title":"URI parameters","text":"<p>The URI parameters are named variables wrapped with  curly braces <code>{}</code> in the URI template string.</p> <pre><code>  -&gt;route('/{param1}/{param2}/{param3}/...')\n</code></pre> <p>If the URI matches the route template, the values of the parameters  will be stored in the <code>Psr\\Http\\Message\\ServerRequestInterface@attributes</code>  and available through the request object with the <code>getAttribute()</code> method</p> <pre><code>&lt;?php\n\n  public function put(ServerRequestInterface $request) {\n    $param1 = $request-&gt;getAttribute('param1');\n    $param2 = $request-&gt;getAttribute('param2');\n    $param3 = $request-&gt;getAttribute('param3');\n    ...\n  }\n</code></pre>"},{"location":"routing/parameters/#parameter-types","title":"Parameter types","text":"<p>The router supports simple types for automatic value typecasts.</p> <p>The values are strings by default</p> <ul> <li>str</li> <li>int</li> <li>float</li> <li>uuid</li> <li>path</li> <li>regex</li> </ul>"},{"location":"routing/parameters/#str","title":"str","text":"<pre><code>  -&gt;route('/{id}') or\n  -&gt;route('/{id:str}')\n\n  // ie. \"/123\" \n  // the value is STRING ('id' =&gt; '123')\n</code></pre>"},{"location":"routing/parameters/#int","title":"int","text":"<pre><code>  -&gt;route('/{id:int}')\n\n  // ie. \"/123\" \n  // the value is INTEGER ('id' =&gt; 123)\n</code></pre>"},{"location":"routing/parameters/#float","title":"float","text":"<pre><code>  -&gt;route('/{lon:float}/{lat:float}')\n\n  // ie. \"/41.9973/21.4325\" \n  // the values are FLOATS ('lon' =&gt; 41.9973, 'lat' =&gt; 21.4325)\n</code></pre>"},{"location":"routing/parameters/#uuid","title":"uuid","text":"<pre><code>  -&gt;route('/{ident:uuid}')\n\n  // ie. \"/7eacf466-321f-4ceb-914e-e525987e7804\" \n  // the value is STRING ('ident' =&gt; '7eacf466-321f-4ceb-914e-e525987e7804')\n</code></pre>"},{"location":"routing/parameters/#path","title":"path","text":"<pre><code>  -&gt;route('/collection/{dir:path}')\n\n  // ie. \"/collection/deeper/subgroup/name\" \n  // the value is STRING ('dir' =&gt; 'deeper/subgroup/name')\n</code></pre> <p>Only one <code>:path</code> parameter is supported</p>"},{"location":"routing/parameters/#regex","title":"regex","text":"<pre><code>  -&gt;route('/{something:regex:\\d+}')\n\n  // ie. \"/123\" \n  // 'something' =&gt; 123\n</code></pre> <p>Keep it simple</p> <p>Try to not overcomplicate your regular expressions, in most cases a simple type is sufficient.</p>"},{"location":"translation/","title":"I18n setup","text":"<p>The world is multilingual and Koded provides a simple I18n implementation.</p> <p>Translation strings are stored on a disk, processed by  a \"catalog\" and accessed with translation function <code>__()</code>.</p> <pre><code>&lt;?php\n\nfunction __(\n  string $string,\n  array $arguments = [],\n  string $locale = ''\n): string\n</code></pre>"},{"location":"translation/#configuration","title":"Configuration","text":"<p>I18n is set in the Koded <code>DIModule</code> and defaults to</p> <ul> <li><code>DefaultCatalog</code> and</li> <li><code>DefaultFormatter</code></li> </ul> <p>Both can be changed in your app configuration:</p> <pre><code>&lt;?php\n\nreturn [\n  'translation.catalog' =&gt; \\Koded\\I18n\\GettextCatalog::class,\n  'translation.formatter' =&gt; \\Koded\\I18n\\StrtrFormatter::class,\n  'translation.dir' =&gt; __DIR__ . '/locale/',\n  'translation.locale' =&gt; 'mk_MK',\n];\n</code></pre>"},{"location":"translation/catalogs/","title":"Storages for translation strings","text":"<p>Koded offers two different catalogs out of the box</p> <ul> <li><code>GettextCatalog</code></li> <li><code>DefaultCatalog</code></li> </ul> <p>Both are doing the same thing and the difference is how the  translated strings are stored.</p> <p>Which one to use?</p> <ul> <li><code>GettextCatalog</code> for projects with lots of languages  (therefore lots of translators).</li> <li><code>DefaultCatalog</code> for simple projects or relatively small amount of strings or languages support.</li> </ul> <p>There is no right or wrong choice, just pick one that you think is easy to work with or is suitable for your project. </p>"},{"location":"translation/catalogs/#defaultcatalog","title":"DefaultCatalog","text":"<p>The strings are stored in the <code>/locale/</code> application  directory in a <code>.php</code> file with a locale name</p> <pre><code>locale\n\u251c\u2500\u2500 de_DE.php\n\u251c\u2500\u2500 en_US.php\n\u2514\u2500\u2500 mk_MK.php\n\netc.\n</code></pre> <p>The structure for the <code>en_US.php</code> translation file is <pre><code>&lt;?php\n\nreturn [\n    'language' =&gt; 'English',\n    'messages' =&gt; [\n    ]\n];\n</code></pre> and all locales are expected to be of the same format.</p>"},{"location":"translation/catalogs/#examples","title":"Examples","text":"<pre><code># locale/en_US.php\n\n&lt;?php\n\nreturn [\n    'language' =&gt; 'English',\n    'messages' =&gt; [\n      'original string' =&gt; 'translated string',\n      'pagination.pages' =&gt; 'page {0} of {1}',\n    ]\n];\n\n# somewhere in your code\n\n__('original string') // outputs: \"translated string\"\n__('pagination.pages', [1, 42]) // outputs: \"page 1 of 42\"\n</code></pre>"},{"location":"translation/catalogs/#gettextcatalog","title":"GettextCatalog","text":"<p>This catalog requires the <code>gettext</code> PHP extension and uses the  excellent translation functionality provided by it.</p> <p>The strings are stored in <code>.po/.mo</code> files within a proper directory structure:</p> <p><pre><code>locale\n\u2514\u2500\u2500 en_US\n    \u2514\u2500\u2500 LC_MESSAGES\n        \u251c\u2500\u2500 messages.mo\n        \u2514\u2500\u2500 messages.po\netc.\n</code></pre> The recommended translation editor is Poedit that supports this kind of translations.</p>"},{"location":"translation/formatters/","title":"Formatters","text":"<p>String formatters are used to replace the translation arguments provided in the <code>__(string, arguments)</code> function. The default  formatter is <code>DefaultFormatter</code> and it's set in the Koded <code>DIModule</code>.</p> <p>Choose one</p> <p>Once you start with translations, the format of the strings with arguments matters, because the argument replacement is different for <code>DefaultFormatter</code> and <code>StrtrFormatter</code>.</p>"},{"location":"translation/formatters/#defaultformatter","title":"DefaultFormatter","text":"<p>This formatter uses the vsprintf PHP function to replace the string arguments with values.</p>"},{"location":"translation/formatters/#strtrformatter","title":"StrtrFormatter","text":"<p>This formatter uses the strtr PHP function to  replace the string arguments with values.</p>"},{"location":"utils/caching/","title":"Application caching (PSR-16)","text":"<p>The (app) caching is bolted-in and always on. The default cache library is Koded Simple Cache.</p> <p>Application caching</p> <p></p> <p>The cache functionality is available in the user app by  simply demanding an instance of PSR-16 <code>Psr\\SimpleCache\\CacheInterface</code> instance. The DI container will inject the configured cache client.</p> <pre><code>&lt;?php\n\n...\n  public function something(CacheInterface $cache) {\n    // ...\n  }\n...\n</code></pre>"},{"location":"utils/caching/#setup-cache","title":"Setup cache","text":"<p>Caching configuration is done in the application configuration for the <code>App</code> instance.</p> <pre><code>&lt;?php\n\nreturn [\n    'caching' =&gt; [\n        //\n    ]\n];\n</code></pre> <pre><code>&lt;?php\n\nnew App(config: 'config.php');\n</code></pre>"},{"location":"utils/caching/#memory","title":"Memory","text":"<p>Default cache is <code>Memory</code> and does not require a special treatment. It will provide caching for the duration of the request which is useful for development and unit testing.</p> <p>Memory (default)</p> <p>No need to set anything in the configuration. This is the default caching client.</p>"},{"location":"utils/logger/","title":"Logging (PSR-5)","text":"<p>Default logging library is Koded Logging.</p> <p>Logging</p> <p></p> <p>Demand an instance of PSR-5 <code>Psr\\Log\\LoggerInterface</code> in your methods, DI container will inject the configured log instance.</p> <pre><code>&lt;?php\n\n...\n  public function something(LoggerInterface $log) {\n    // ...\n  }\n...\n</code></pre>"},{"location":"utils/logger/#setup-logging","title":"Setup logging","text":"<p>Logger library is configured in the \\ application configuration for the <code>App</code> instance.</p> <pre><code>&lt;?php\n\nreturn [\n  'logging' =&gt; [\n    'timezone' =&gt; 'UTC',\n    'dateformat' =&gt; 'Y-m-d H:i:s.u'\n    'loggers' =&gt; [\n      [\n        'class' =&gt; \\Koded\\Logging\\Processors\\Cli::class,\n        'format' =&gt; '[levelname] message',\n        'levels' =&gt; -1\n      ]\n    ]\n  ],\n];\n</code></pre> <p>The conf key <code>loggers</code> is a list of <code>Koded\\Logging\\Log</code>  log processor implementations. By default only one log processor is registered that processes all log levels.</p>"}]}